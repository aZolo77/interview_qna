# Контекст наложения (Stacking Context) в CSS

## Кратко
Контекст наложения — это набор правил, по которым браузер определяет порядок отображения элементов на оси **z** (глубина). Можно представить это как колоду карт: порядок наложения решает, какая карта окажется сверху.

---

## Как работает браузер
- По умолчанию элементы рисуются в порядке, в котором они указаны в HTML.  
- Если элементы перекрываются, тот, что идёт позже в DOM, будет "выше".  
- Но свойство **z-index** и создание новых контекстов наложения могут менять этот порядок.

Пример:

```html
<div class="block first"></div>
<div class="block second"></div>
```

```css
.second {
  margin-top: -50px;
  margin-left: 50px;
}
```

Здесь `.second` перекрывает `.first`, потому что он идёт в DOM позже.

---

## z-index
**z-index** управляет порядком наложения, но работает **только для элементов, у которых есть позиционирование** (`relative`, `absolute`, `fixed`, `sticky`).

Пример:

```css
.first {
  position: relative;
  z-index: 1;
}
```

Теперь `.first` окажется выше `.second`, даже если в DOM он раньше.

---

## Что такое контекст наложения
Контекст наложения — это "своя колода карт".  
Все элементы внутри одного контекста сравниваются только между собой.  
Даже если у вложенного элемента `z-index: 9999`, он **не выйдет за пределы своего контекста** и не перекроет родителя.

**Базовый контекст наложения** создаётся корневым элементом `<html>`.  
Новые контексты наложения создаются, если:

- Элемент имеет `position` (кроме static) и `z-index`, отличный от `auto`;
- Элемент с `position: fixed` или `sticky`;
- Элемент с `opacity < 1`;
- Элемент с `transform`, `filter`, `perspective`, `clip-path`, `mask`, `will-change`;
- Элемент с `isolation: isolate`;
- Элемент с `mix-blend-mode ≠ normal`;
- Флекс- или грид-элемент с ненулевым `z-index`.

---

## Важный момент
- **Внутри одного контекста наложения** порядок элементов определяется `z-index` и порядком в DOM.  
- **Между разными контекстами наложения** элементы сравниваются как целые "колоды": вложенный элемент не может перекрыть родителя.

Пример:

```html
<div class="parent">
  <div class="child yellow"></div>
  <div class="child red"></div>
</div>
<div class="no-parent"></div>
```

```css
.parent {
  position: relative;
  z-index: 1; /* создаёт новый контекст */
}

.yellow {
  position: relative;
  z-index: 9999; /* работает только внутри .parent */
}
```

Даже с `z-index: 9999`, `.yellow` не перекроет `.no-parent`, так как они в разных контекстах.

---

## Порядок отрисовки внутри одного контекста
От нижнего к верхнему уровню:

1. Фон и рамки элемента.
2. Элементы с отрицательным z-index.
3. Блочные элементы без контекста наложения.
4. Элементы с float.
5. Инлайновые элементы.
6. Элементы с z-index: auto/0 и `opacity < 1`.
7. Элементы с положительным z-index.

⚠ Элемент с `z-index: -1` не уйдёт под фон или рамку родителя — он всегда останется поверх них.

---

## На собеседовании стоит упомянуть
- Частая ошибка: разработчики думают, что `z-index` всегда "абсолютный". На самом деле он работает **только внутри своего контекста наложения**.  
- Причины багов с наложением часто связаны с `opacity`, `transform` или `z-index` у родителей.  
- Хорошая практика: стараться избегать слишком больших z-index (`9999999`). Лучше планировать иерархию слоёв.  
- У некоторых UI-библиотек (например, Material UI, Bootstrap) есть **своя система уровней z-index** для модалок, тултипов и т.д. — об этом стоит помнить, если в проекте используются готовые компоненты.

---

## Итог
Контекст наложения — это не только про `z-index`, а про **иерархию слоёв в трёхмерной модели страницы**. Чтобы уверенно работать с UI, важно понимать:
- когда создаётся новый контекст,
- что `z-index` работает только в пределах этого контекста,
- как правильно управлять слоями для модалок, dropdown-меню и других элементов интерфейса.

# WebSocket

## Что это
Протокол **WebSocket** (RFC 6455) — это технология, которая обеспечивает **постоянное двустороннее соединение** между клиентом (браузером) и сервером.  
В отличие от HTTP-запросов, которые требуют новых подключений на каждый запрос, WebSocket позволяет обмениваться данными в реальном времени без постоянных перезапросов.

---

## Основные характеристики
- **Двусторонний обмен**: клиент и сервер могут отправлять сообщения в любое время.
- **Постоянное соединение**: открывается один TCP-сокет, который не разрывается после ответа.
- **Формат данных**: текстовые и бинарные данные.
- **Поддержка событий**: удобное API через события `open`, `message`, `error`, `close`.

---

## Пример клиента

```js
let socket = new WebSocket("wss://example.com");

socket.onopen = () => {
  console.log("Соединение установлено");
  socket.send("Привет сервер!");
};

socket.onmessage = (event) => {
  console.log("Сообщение от сервера:", event.data);
};

socket.onerror = (err) => {
  console.error("Ошибка:", err);
};

socket.onclose = (event) => {
  console.log("Соединение закрыто:", event.code, event.reason);
};
```

---

## Протоколы ws:// и wss://
- `ws://` — без шифрования, как `http://`.
- `wss://` — защищённое соединение (TLS), как `https://`.  
Для продакшена всегда используют **wss://**, так как это безопаснее и совместимо с прокси/фаерволами.

---

## Заголовки при установке соединения
Пример запроса:

```
GET /chat
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: random_key
Sec-WebSocket-Version: 13
```

Сервер отвечает:

```
101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: encoded_key
```

После этого соединение переходит в режим WebSocket.

---

## Структура данных (фреймы)
Сообщения передаются в виде **фреймов**:
- текстовые,
- бинарные,
- служебные (ping/pong, закрытие соединения).

Пример:

```js
socket.send("Текстовое сообщение");
socket.binaryType = "arraybuffer";

socket.onmessage = (event) => {
  if (event.data instanceof ArrayBuffer) {
    console.log("Бинарные данные:", event.data);
  } else {
    console.log("Текст:", event.data);
  }
};
```

---

## Управление соединением
Закрытие:

```
socket.close(1000, "работа завершена");
```

Состояния сокета (`readyState`):
- `0` — CONNECTING,
- `1` — OPEN,
- `2` — CLOSING,
- `3` — CLOSED.

---

## Где применяются WebSocket
- **Онлайн-игры** с большим количеством игроков.
- **Чаты и мессенджеры**.
- **Торговые площадки** (биржи, e-commerce) с обновлениями цен в реальном времени.
- **Совместная работа** (редакторы, доски).
- **Мониторинг и IoT** (например, обновление сенсорных данных).

---

## Сравнение с другими подходами
- **Long Polling** — клиент периодически спрашивает сервер: «есть ли обновления?». Неэффективно.
- **SSE (Server-Sent Events)** — сервер может отправлять данные клиенту, но клиент не может посылать сообщения обратно. Односторонний канал.
- **WebSocket** — двусторонний обмен, подходит для реального времени.

---

## Важные моменты для собеседования
- WebSocket не заменяет HTTP: для авторизации и первоначальной загрузки данных всё ещё используется HTTP.
- Часто используется вместе с **JWT-токенами** или cookie для аутентификации.
- Для надёжности реализуют:
  - механизм переподключения (reconnect),
  - heartbeats (ping/pong),
  - обработку обрывов сети.
- На продакшене обычно применяют готовые библиотеки (например, **Socket.IO**) поверх WebSocket для упрощения разработки (поддержка fallback-методов, reconnection, namespaces, rooms).

---

## Итог
WebSocket — это **мощный инструмент для приложений в реальном времени**, где требуется:
- минимальная задержка,
- двусторонний обмен,
- поддержка бинарных и текстовых данных.  

На собеседовании можно подчеркнуть, что как frontend-разработчик ты понимаешь:
- когда WebSocket уместнее, чем REST или SSE,
- как с ним работать на уровне API,
- какие проблемы (reconnect, безопасность, нагрузка) нужно решать в реальных проектах.

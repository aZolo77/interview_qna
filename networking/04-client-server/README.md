# Протоколы и подходы для общения клиент ↔ сервер — разложим по полочкам

Коротко: есть два принципиально разных подхода — **request/response** (HTTP/REST и производные) и **push/stream** (WebSocket, SSE, WebRTC и т.д.). Понимать, чем они отличаются, — значит не путаться на собесе и выбирать правильный инструмент в продукте.

---

## 1) Основная классификация (в одну строку)
- **HTTP (REST, GraphQL, gRPC-web)** — запрос → ответ. Хорошо для CRUD, кэширования, SEO, CDN.  
- **Long Polling / Polling** — эмуляция обновлений через частые HTTP-запросы. Простое, но неэффективно при высокой частоте.  
- **SSE (Server-Sent Events)** — односторонний канал: сервер → клиент (текст). Лёгкий, автопереподключение.  
- **WebSocket** — двусторонний, постоянный, низкая латентность, поддерживает бинарные данные. Отлично для чатов, игр, торгах.  
- **WebRTC** — пировая передача audio/video и data-каналов; часто для стримов и P2P real-time.  
- **HTTP/2 & HTTP/3** — улучшенные версии HTTP: мультиплекс, меньшая латентность, HTTP/2 server push (ограниченно полезен).

---

## 2) Сравнительная таблица (быстрое ориентирование)

| Фича / Вопрос | HTTP/REST | Polling / Long Polling | SSE | WebSocket | WebRTC |
|---|---:|---:|---:|---:|---:|
| Модель | request → response | эмуляция push через запросы | server → client (event stream) | full-duplex socket | p2p media/data |
| Двусторонний | нет (можно отправить новый запрос) | нет (кроме запросов) | нет | да | да |
| Поддержка бинарных данных | да (body) | да | нет (только текст) | да | да |
| Подключение через прокси/CDN | хорошо | да | может быть | иногда проблемы с прокси | сложнее (ICE/STUN needed) |
| Простота реализации | очень | очень | просто (EventSource) | средняя | сложная |
| Масштабирование на сервере | простое (stateless) | простое | простое | требует state/sticky или брокера (Redis) | сложное |
| Примеры применения | CRUD, страницы, API | редкие обновления, бэкенд-агрегация | ленты новостей, метрики | чаты, игры, коллаб, торги | видеозвонки, P2P стримы |

---

## 3) Глубже — что и когда выбирать (практика)

### Когда использовать **HTTP / REST / GraphQL / gRPC-web**
- Стандартный CRUD (GET/POST/PUT/DELETE).  
- Нужна хорошая поддержка кэша (CDN), idempotency, SEO.  
- Когда endpoints просты, и real-time не критичен.  
- **Плюсы:** легко масштабировать, безопасно, понятный стек.  
- **Минусы:** неэффективен для частых обновлений в реальном времени.

Пример (fetch):

```js
    fetch('/api/items')
      .then(r => r.json())
      .then(data => console.log(data));
```

### Когда **polling / long polling**
- Если сервер не поддерживает push и обновления редкие.  
- Long polling: клиент делает запрос и держит его до появления данных — затем сразу новый запрос.  
- **Плюсы:** работает везде, простая реализация.  
- **Минусы:** нагрузка на сервер/latency.

### Когда **SSE (EventSource)**
- Когда нужны частые односторонние обновления от сервера (лог, счетчик, live feed).  
- Простая реализация в браузере: EventSource автоматически переподключается.  
- **Ограничение:** только текстовый stream (event: / data:), нет бинарки, нет двусторонности (нужно отдельный POST для клиента → сервер).  
- **Плюсы:** легковесно, автоматические реконекты, хорошо для метрик/уведомлений.  
- **Минусы:** не во всех прокси идеально, нельзя из браузера задать произвольные заголовки (токены через cookie/URL).

Пример (EventSource):

```js
    const es = new EventSource('/events');
    es.onmessage = e => console.log('server:', e.data);
```

### Когда **WebSocket**
- Нужен двусторонний, низколатентный канал: чаты, игры, торговые стаканы, collaborative editing.  
- Поддерживает бинарные сообщения (Blob/ArrayBuffer).  
- **Требования на сервер:** держать соединение, вертикальное/горизонтальное масштабирование (обычно нужен брокер/пуб-саб и sticky session).  
- **Безопасность:** используй wss:// в проде. Аутентификация: cookie или токен (в query param — осторожно).  
- **Минусы:** сложнее масштабировать, требует управления переподключением/heartbeat.

Клиент-пример:

```js
    const ws = new WebSocket('wss://example.com/ws');
    ws.onopen = () => ws.send('hello');
    ws.onmessage = e => console.log(e.data);
```

### Когда **WebRTC**
- Если нужно передавать аудио/видео или P2P data с минимальной задержкой.  
- Используется для видео-звонков, трансляций, P2P обмена файлами.  
- **Сложности:** установка соединения (ICE/STUN/TURN), сигнализация (обычно через WebSocket/HTTP), NAT traversal.  
- **Плюсы:** пировая передача, низкие задержки для media.  
- **Минусы:** сложная инфраструктура (TURN сервера, масштабирование).

---

## 4) Архитектурные и операционные моменты / подводные камни (на собесе любят спрашивать)

- **Stateful vs Stateless:** HTTP лучше масштабируется (stateless). WebSocket держит state (подключение) — нужны sticky sessions или центральный брокер/pubsub (Redis, NATS, Kafka).  
- **Load balancer / proxy:** некоторые старые прокси плохо работают с WebSocket; wss помогает. SSE использует long-lived HTTP connection — убедись в поддержке (timeout).  
- **Authentication:** в WebSocket запросе нельзя задать произвольные кастомные заголовки из конструктора (в браузерах). Рекомендации: сначала authenticate через HTTP (cookie / JWT), затем открыть WS; либо передать токен в query (не идеально), либо использовать subprotocols (часто неудобно). SSE не позволяет кастомные заголовки — cookie или одноразовый token в URL.  
- **Reconnection & backoff:** всегда реализуй экспоненциальный бэкофф и jitter при переподключении.  
- **Heartbeats / keepalive:** отправляй ping/pong (или application-level heartbeat) для детекции мёртвых соединений.  
- **Buffering / flow control:** у WebSocket есть bufferedAmount — следи, если отправляешь много данных.  
- **Security:** TLS (wss), CORS/Origin проверка на сервере, защита от DoS (много соединений) — лимиты, rate-limiting.  
- **Scalability:** для множества клиентов используйте pub/sub (Redis, Kafka) и обработчики, чтобы при горизонтальном масштабировании бэкенда все ноды могли публиковать/получать сообщения.  
- **Monitoring:** WebSocket-соединения сложнее мониторить (кол-во open), отслеживай latency, reconnects, errored connections.

---

## 5) Короткие «говорилки» для собеседования (шпаргалка — 1–2 фразы)
- «HTTP/REST — для CRUD и кэшируемых ресурсов; WebSocket — для низколатентного двустороннего обмена.»  
- «SSE удобен для server→client стримов: простая реализация и авто-репконнект.»  
- «WebSocket требует управления состоянием на сервере (sticky sessions или pub/sub) — это важно при масштабировании.»  
- «Для медиа и P2P лучше WebRTC: WebSocket не заменит аудио/видео стриминг с низкой задержкой.»

---

## 6) Быстрая подсказка: что ответить в ситуациях
- «Клиент должен только получать обновления (лишь сервер→клиент)» → SSE (или WebSocket, если планируете расширять до двустороннего).  
- «Нужно отправлять/принимать сообщения/команды в реальном времени» → WebSocket.  
- «Видео/аудио звонки» → WebRTC (+ сигнализация через WebSocket).  
- «Нужно простое решение и неважна задержка» → Polling (или REST с периодическими запросами).  
- «Нужна двусторонняя связь, но хочется абстракции и fallback-ов» → библиотека типа Socket.IO (она поддерживает fallbacks).

---

## 7) Примеры кода (микро-сниппеты, без лишних украшательств)

HTTP fetch:

```js
    fetch('/api/items')
      .then(res => res.json())
      .then(data => console.log(data));
```

SSE:

```js
    const es = new EventSource('/events');
    es.onmessage = e => console.log('event:', e.data);
```

WebSocket:

```js
    const ws = new WebSocket('wss://example.com/ws');
    ws.onopen = () => ws.send('hello');
    ws.onmessage = e => console.log('msg:', e.data);
```

Long polling (very simple):

```js
    async function poll() {
      const res = await fetch('/longpoll');
      const data = await res.json();
      handle(data);
      poll(); // сразу новый запрос
    }
    poll();
```

WebRTC (signal step only — high level):
    1) сигнализация через WebSocket / HTTP
    2) RTCPeerConnection + createOffer / setLocalDescription / setRemoteDescription
    3) ICE, STUN/TURN

---

## 8) Резюме — как не путаться
1. Сначала задать вопрос: **нужна ли двусторонняя связь?**  
   - Нет → HTTP/REST/SSE.  
   - Да → WebSocket/WebRTC.  
2. Оценить частоту обновлений и требования к latency.  
3. Подумать про масштабирование: stateless vs stateful.  
4. Продумать auth (cookie/JWT), безопасность (wss/HTTPS) и reconnect strategy.  
5. Если не хочешь утруждаться — используй готовую библиотеку (Socket.IO, Phoenix Channels и т.п.), но будь готов объяснить, что она делает под капотом.


# Как работает сборщик мусора

## 1. Основная идея

JavaScript имеет **автоматическое управление памятью** - разработчик не освобождает память вручную. Сборщик мусора (Garbage Collector, GC) удаляет объекты, которые стали **недостижимыми**.

### Достижимость

-   Корневые объекты (**roots**): глобальные переменные, текущий стек вызовов, замыкания.
-   Объект считается достижимым, если на него можно добраться по ссылкам от корней.
-   Всё, что недостижимо, считается мусором и удаляется.

---

## 2. Принцип работы GC

### Алгоритм *mark-and-sweep* (пометка и очистка):

1.  **Mark (пометка):** GC находит все корневые объекты и помечает их.
2.  **Traverse (обход):** идёт по ссылкам и помечает все доступные объекты.
3.  **Sweep (очистка):** удаляет все объекты, до которых невозможно добраться.

Пример:

```js
let user = { name: "John" };
user = null; 
// объект { name: "John" } больше недостижим → будет удалён GC
```

---

## 3. Важные примеры

### Несколько ссылок

```js
let user = { name: "John" };
let admin = user;

user = null;
// объект всё ещё достижим через admin
```

### Взаимосвязанные объекты

```js
function marry(man, woman) {
    man.wife = woman;
    woman.husband = man;

    return { father: man, mother: woman };
}

let family = marry({name: "John"}, {name: "Ann"});

family = null;
// "остров" John ↔ Ann больше недостижим → удалится GC
```

---

## 4. Современные оптимизации

JS-движки (например, V8) используют дополнительные алгоритмы для скорости и уменьшения пауз: **Generational GC** - новые объекты очищаются чаще, старые реже.
- **Incremental GC** - работа делится на небольшие шаги, чтобы не блокировать выполнение кода.
- **Idle-time GC** - сборка мусора запускается в моменты простоя процессора.

---

## 5. Важные нюансы для разработчика

-   Сборка мусора **автоматическая**: вызвать её вручную нельзя (хотя в некоторых движках есть отладочные API).
-   Утечки памяти всё равно возможны, если сохранять ненужные ссылки:
    -   глобальные переменные;
    -   замыкания, удерживающие большие объекты;
    -   коллекции (`Map`, `Set`), в которые забыли удалить значения;
    -   таймеры/обработчики событий, не удалённые после использования.

Пример утечки:

```js
let cache = {};

function rememberUser(user) {
    cache[user.id] = user; 
}
// даже если user больше нигде не используется, ссылка в cache удерживает объект
```

---

## Итог

-   GC в JS основан на принципе достижимости и алгоритме *mark-and-sweep*.
-   Объекты живут, пока на них можно добраться по цепочке ссылок от корней.
-   Разработчик не управляет памятью напрямую, но должен следить за **утечками памяти**.
-   Знание нюансов GC помогает писать производительный и устойчивый код.

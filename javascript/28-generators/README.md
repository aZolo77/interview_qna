# Генераторы

## Кратко
Обычные функции возвращают только одно-единственное значение (или ничего).  
**Генераторы** могут порождать (yield) множество значений одно за другим, по мере необходимости.  
Они отлично работают с перебираемыми объектами и позволяют легко создавать потоки данных.

---

## Функция-генератор
Для объявления генератора используется специальная конструкция `function*`:

```js
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
```

Когда такая функция вызвана, она возвращает объект **генератор**, а не запускает выполнение сразу. Управление идёт через метод **next()**.

Пример:

```js
let generator = generateSequence();
console.log(generator.next()); // { value: 1, done: false }
console.log(generator.next()); // { value: 2, done: false }
console.log(generator.next()); // { value: 3, done: true }
```

---

## Основные возможности генераторов

### 1. Перебор значений
Генератор можно использовать в `for...of`:

```js
function* generateSequence() {
  yield 1;
  yield 2;
  yield 3;
}

for (let value of generateSequence()) {
  console.log(value); // 1, 2, 3
}
```

Важно: `return` в генераторе не попадает в перебор, только `yield`.

---

### 2. Генераторы как перебираемые объекты
Генератор — это итератор. Значит, можно использовать оператор spread:

```js
let sequence = [0, ...generateSequence()];
console.log(sequence); // [0, 1, 2, 3]
```

---

### 3. Упрощение написания итераторов
Генераторы делают итераторы короче:

```js
let range = {
  from: 1,
  to: 3,
  *[Symbol.iterator]() {
    for (let value = this.from; value <= this.to; value++) {
      yield value;
    }
  }
};

console.log([...range]); // [1, 2, 3]
```

---

### 4. Бесконечные последовательности
Генератор может работать бесконечно:

```js
function* infiniteNumbers() {
  let i = 0;
  while (true) yield i++;
}

for (let n of infiniteNumbers()) {
  if (n > 5) break;
  console.log(n);
}
```

---

### 5. Композиция генераторов
Один генератор может делегировать работу другому через `yield*`:

```js
function* generatePasswordCodes() {
  yield* generateSequence(48, 57);  // 0..9
  yield* generateSequence(65, 90);  // A..Z
  yield* generateSequence(97, 122); // a..z
}
```

---

### 6. Двусторонняя передача данных
Через `next(value)` можно **передавать данные обратно в генератор**:

```js
function* gen() {
  let result = yield "2 + 2 = ?";
  console.log(result); // выведет 4
}

let generator = gen();
console.log(generator.next().value); // "2 + 2 = ?"
generator.next(4);
```

---

### 7. Ошибки через generator.throw
Можно «вбросить» ошибку внутрь генератора:

```js
function* gen() {
  try {
    let result = yield "Вычисляем...";
    console.log(result);
  } catch (e) {
    console.log("Ошибка:", e.message);
  }
}

let generator = gen();
console.log(generator.next().value);
generator.throw(new Error("Что-то пошло не так"));
```

---

## Асинхронные генераторы
Есть также `async function*`, которые позволяют работать с асинхронными потоками (например, постраничная загрузка данных).  
Они используются вместе с `for await...of`.

---

## Где применяются генераторы
- Упрощение написания итераторов (например, range).
- Потоковые данные (например, генерация чисел, чанков данных).
- Управление асинхронностью (до появления `async/await` часто использовались с библиотеками типа co).
- Ленивая генерация данных (создание значений по требованию).
- Реализация сложных последовательностей без хранения всего массива в памяти.

---

## Дополнительно для собеседования
- **Генераторы ≠ async/await.** Async/await — это синтаксический сахар поверх промисов, а генераторы могут использоваться шире, в том числе для синхронных задач.
- Генераторы позволяют **экономить память**, так как данные создаются по запросу.
- С их помощью можно реализовать собственные версии **Observable-подобных структур** (аналог RxJS), где генератор эмитит значения.
- В комбинации с `yield*` генераторы помогают строить **модульные пайплайны** для обработки данных.
